{
  "address": "0xCd5695Ab4EFE1e5f4EFCD05957Ca80C5d6feF2A3",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "contract GameBaseToken",
          "name": "gameTokenContract",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "trustedForwarder",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "gameMintingFee",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "gameUpdateFee",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "feeBeneficiary",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "sand",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "to",
          "type": "address"
        },
        {
          "components": [
            {
              "internalType": "uint256[]",
              "name": "assetIdsToRemove",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "assetAmountsToRemove",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "assetIdsToAdd",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "assetAmountsToAdd",
              "type": "uint256[]"
            },
            {
              "internalType": "bytes32",
              "name": "uri",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "exactNumOfLandsRequired",
              "type": "uint256"
            }
          ],
          "internalType": "struct IGameToken.GameData",
          "name": "creation",
          "type": "tuple"
        },
        {
          "internalType": "address",
          "name": "editor",
          "type": "address"
        },
        {
          "internalType": "uint64",
          "name": "subId",
          "type": "uint64"
        }
      ],
      "name": "createGame",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getTrustedForwarder",
      "outputs": [
        {
          "internalType": "address",
          "name": "trustedForwarder",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "forwarder",
          "type": "address"
        }
      ],
      "name": "isTrustedForwarder",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "gameId",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "uint256[]",
              "name": "assetIdsToRemove",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "assetAmountsToRemove",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "assetIdsToAdd",
              "type": "uint256[]"
            },
            {
              "internalType": "uint256[]",
              "name": "assetAmountsToAdd",
              "type": "uint256[]"
            },
            {
              "internalType": "bytes32",
              "name": "uri",
              "type": "bytes32"
            },
            {
              "internalType": "uint256",
              "name": "exactNumOfLandsRequired",
              "type": "uint256"
            }
          ],
          "internalType": "struct IGameToken.GameData",
          "name": "update",
          "type": "tuple"
        }
      ],
      "name": "updateGame",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "newId",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xd6bc0706797784c52a04b56fb4763ad6857e0cd9ee500ff8bf290931b798c97f",
  "receipt": {
    "to": null,
    "from": "0x5F890c9522dCE5670d741D4277BFCC2d9cA8Af02",
    "contractAddress": "0xCd5695Ab4EFE1e5f4EFCD05957Ca80C5d6feF2A3",
    "transactionIndex": 13,
    "gasUsed": "775720",
    "logsBloom": "0x00000000000000020000000000000000000000000000000000000000000000000002000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000200000200000000000000020000000000000000001000000000000000000000000004000000000000000000001000000000000000000000000000000108000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x7143cb946ad7d24d7a2a85a6659b00edb3810c431ccd1bc0f73492f04a1fd8cb",
    "transactionHash": "0xd6bc0706797784c52a04b56fb4763ad6857e0cd9ee500ff8bf290931b798c97f",
    "logs": [
      {
        "transactionIndex": 13,
        "blockNumber": 24684725,
        "transactionHash": "0xd6bc0706797784c52a04b56fb4763ad6857e0cd9ee500ff8bf290931b798c97f",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x0000000000000000000000005f890c9522dce5670d741d4277bfcc2d9ca8af02",
          "0x000000000000000000000000c26880a0af2ea0c7e8130e6ec47af756465452e8"
        ],
        "data": "0x0000000000000000000000000000000000000000000000000002c183630b90000000000000000000000000000000000000000000000000001918e10232450c32000000000000000000000000000000000000000000000599e021e7fda0c0279b00000000000000000000000000000000000000000000000019161f7ecf397c32000000000000000000000000000000000000000000000599e024a98103cbb79b",
        "logIndex": 55,
        "blockHash": "0x7143cb946ad7d24d7a2a85a6659b00edb3810c431ccd1bc0f73492f04a1fd8cb"
      }
    ],
    "blockNumber": 24684725,
    "cumulativeGasUsed": "2917769",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x6bDCA93BE8f547A11058F720FEfd51827Ff81c77",
    "0x9399BB24DBB5C4b782C70c2969F58716Ebbd6a3b",
    300,
    100,
    "0xa5Eb9C9Eb4F4c35B9Be8cFaAA7909F9ebe6Cb609",
    "0x592daadC9eA7F56A81De1FD27A723Bd407709c46"
  ],
  "solcInputHash": "c98e50b6aaa9e2d9246638fbda3bd3e3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.2+commit.661d1103\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract GameBaseToken\",\"name\":\"gameTokenContract\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"trustedForwarder\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"gameMintingFee\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"gameUpdateFee\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"feeBeneficiary\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"sand\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"to\",\"type\":\"address\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"assetIdsToRemove\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"assetAmountsToRemove\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"assetIdsToAdd\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"assetAmountsToAdd\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32\",\"name\":\"uri\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"exactNumOfLandsRequired\",\"type\":\"uint256\"}],\"internalType\":\"struct IGameToken.GameData\",\"name\":\"creation\",\"type\":\"tuple\"},{\"internalType\":\"address\",\"name\":\"editor\",\"type\":\"address\"},{\"internalType\":\"uint64\",\"name\":\"subId\",\"type\":\"uint64\"}],\"name\":\"createGame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getTrustedForwarder\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"trustedForwarder\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"forwarder\",\"type\":\"address\"}],\"name\":\"isTrustedForwarder\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"gameId\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"uint256[]\",\"name\":\"assetIdsToRemove\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"assetAmountsToRemove\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"assetIdsToAdd\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"assetAmountsToAdd\",\"type\":\"uint256[]\"},{\"internalType\":\"bytes32\",\"name\":\"uri\",\"type\":\"bytes32\"},{\"internalType\":\"uint256\",\"name\":\"exactNumOfLandsRequired\",\"type\":\"uint256\"}],\"internalType\":\"struct IGameToken.GameData\",\"name\":\"update\",\"type\":\"tuple\"}],\"name\":\"updateGame\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"newId\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createGame(address,(uint256[],uint256[],uint256[],uint256[],bytes32,uint256),address,uint64)\":{\"params\":{\"creation\":\"The struct containing ids & ammounts of assets to add to this game, along with the uri to set.\",\"editor\":\"The address to allow to edit (can also be set later).\",\"subId\":\"A random id created on the backend.\",\"to\":\"The address who will be assigned ownership of this game.\"},\"returns\":{\"gameId\":\"The id of the new GAME token (erc721)\"}},\"updateGame(uint256,(uint256[],uint256[],uint256[],uint256[],bytes32,uint256))\":{\"params\":{\"gameId\":\"The current id of the GAME token.\",\"update\":\"The values to use for the update.\"},\"returns\":{\"newId\":\"The new gameId.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"createGame(address,(uint256[],uint256[],uint256[],uint256[],bytes32,uint256),address,uint64)\":{\"notice\":\"Function to create a new GAME token\"},\"updateGame(uint256,(uint256[],uint256[],uint256[],uint256[],bytes32,uint256))\":{\"notice\":\"Update an existing GAME token.This actually burns old token and mints new token with same basId & incremented version.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/solc_0.8/Game/GameMinter.sol\":\"GameMinter\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":2000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xf8e8d118a7a8b2e134181f7da655f6266aa3a0f9134b2605747139fcb0c5d835\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/AddressUpgradeable.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() initializer {}\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n    /**\\n     * @dev Indicates that the contract has been initialized.\\n     */\\n    bool private _initialized;\\n\\n    /**\\n     * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n    bool private _initializing;\\n\\n    /**\\n     * @dev Modifier to protect an initializer function from being invoked twice.\\n     */\\n    modifier initializer() {\\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\\n        // contract may have been reentered.\\n        require(_initializing ? _isConstructor() : !_initialized, \\\"Initializable: contract is already initialized\\\");\\n\\n        bool isTopLevelCall = !_initializing;\\n        if (isTopLevelCall) {\\n            _initializing = true;\\n            _initialized = true;\\n        }\\n\\n        _;\\n\\n        if (isTopLevelCall) {\\n            _initializing = false;\\n        }\\n    }\\n\\n    /**\\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} modifier, directly or indirectly.\\n     */\\n    modifier onlyInitializing() {\\n        require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n        _;\\n    }\\n\\n    function _isConstructor() private view returns (bool) {\\n        return !AddressUpgradeable.isContract(address(this));\\n    }\\n}\\n\",\"keccak256\":\"0x68861bcc80cacbd498efde75aab6c74a486cc48262660d326c8d7530d9752097\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title ERC721 token receiver interface\\n * @dev Interface for any contract that wants to support safeTransfers\\n * from ERC721 asset contracts.\\n */\\ninterface IERC721ReceiverUpgradeable {\\n    /**\\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\\n     * by `operator` from `from`, this function is called.\\n     *\\n     * It must return its Solidity selector to confirm the token transfer.\\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\\n     *\\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\\n     */\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4);\\n}\\n\",\"keccak256\":\"0x2f359f9d5c56394e60d74401487ab55d8ef0012907b07c9abbb8f998bf5ddfec\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165Upgradeable.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721Upgradeable is IERC165Upgradeable {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool _approved) external;\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external;\\n}\\n\",\"keccak256\":\"0x714a33fd66816f608f6eda908da24eb6009eee50adf4062c86639d4fe508a7b6\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary AddressUpgradeable {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        uint256 size;\\n        assembly {\\n            size := extcodesize(account)\\n        }\\n        return size > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCall(target, data, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        require(isContract(target), \\\"Address: static call to non-contract\\\");\\n\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResult(success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            // Look for revert reason and bubble it up if present\\n            if (returndata.length > 0) {\\n                // The easiest way to bubble the revert reason is using memory via assembly\\n\\n                assembly {\\n                    let returndata_size := mload(returndata)\\n                    revert(add(32, returndata), returndata_size)\\n                }\\n            } else {\\n                revert(errorMessage);\\n            }\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x3f0f878c796dfc7feba6d3c4e3e526c14c7deae8b7bfc71088e3f38fab0d77b3\",\"license\":\"MIT\"},\"@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165Upgradeable {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xc6cef87559d0aeffdf0a99803de655938a7779ec0a3cd5d4383483ad85565a09\",\"license\":\"MIT\"},\"src/solc_0.8/Game/GameBaseToken.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\npragma solidity 0.8.2;\\n\\nimport \\\"../common/BaseWithStorage/ImmutableERC721.sol\\\";\\nimport \\\"../common/BaseWithStorage/WithMinter.sol\\\";\\nimport \\\"../common/interfaces/IAssetToken.sol\\\";\\nimport \\\"../common/interfaces/IGameToken.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\\\";\\n\\ncontract GameBaseToken is ImmutableERC721, WithMinter, Initializable, IGameToken {\\n    ///////////////////////////////  Data //////////////////////////////\\n\\n    IAssetToken internal _asset;\\n\\n    bytes4 private constant ERC1155_RECEIVED = 0xf23a6e61;\\n    bytes4 private constant ERC1155_BATCH_RECEIVED = 0xbc197c81;\\n\\n    mapping(uint256 => mapping(uint256 => uint256)) private _gameAssets;\\n    mapping(uint256 => address) private _creatorship; // creatorship transfer\\n\\n    mapping(uint256 => bytes32) private _metaData;\\n    mapping(address => mapping(address => bool)) private _gameEditors;\\n    mapping(uint256 => uint256) internal _exactNumOfLandsRequired;\\n    ///////////////////////////////  Events //////////////////////////////\\n\\n    /// @dev Emits when a game is updated.\\n    /// @param oldId The id of the previous erc721 GAME token.\\n    /// @param newId The id of the newly minted token.\\n    /// @param update The changes made to the Game: new assets, removed assets, uri\\n\\n    event GameTokenUpdated(uint256 indexed oldId, uint256 indexed newId, IGameToken.GameData update);\\n\\n    /// @dev Emits when creatorship of a GAME token is transferred.\\n    /// @param original The original creator of the GAME token.\\n    /// @param from The current 'creator' of the token.\\n    /// @param to The new 'creator' of the token.\\n    event CreatorshipTransfer(address indexed original, address indexed from, address indexed to);\\n\\n    /// @dev Emits when an address has its gameEditor status changed.\\n    /// @param gameOwner The owner of the GAME token.\\n    /// @param gameEditor The address whose editor rights to update.\\n    /// @param isEditor WHether the address 'gameEditor' should be an editor.\\n    event GameEditorSet(address indexed gameOwner, address gameEditor, bool isEditor);\\n\\n    function initV1(\\n        address trustedForwarder,\\n        address admin,\\n        IAssetToken asset,\\n        uint8 chainIndex\\n    ) public initializer() {\\n        _admin = admin;\\n        _asset = asset;\\n        ERC721BaseToken.__ERC721BaseToken_initialize(chainIndex);\\n        ERC2771Handler.__ERC2771Handler_initialize(trustedForwarder);\\n    }\\n\\n    ///////////////////////////////  Modifiers //////////////////////////////\\n\\n    modifier notToZero(address to) {\\n        require(to != address(0), \\\"DESTINATION_ZERO_ADDRESS\\\");\\n        _;\\n    }\\n\\n    modifier notToThis(address to) {\\n        require(to != address(this), \\\"DESTINATION_GAME_CONTRACT\\\");\\n        _;\\n    }\\n\\n    ///////////////////////////////  Functions //////////////////////////////\\n\\n    /// @notice Create a new GAME token.\\n    /// @param from The address of the one creating the game (may be different from msg.sender if metaTx).\\n    /// @param to The address who will be assigned ownership of this game.\\n    /// @param creation The struct containing ids & ammounts of assets to add to this game,\\n    /// along with the uri to set.\\n    /// @param editor The address to allow to edit (can also be set later).\\n    /// @param subId A random id created on the backend.\\n    /// @return id The id of the new GAME token (erc721).\\n    function createGame(\\n        address from,\\n        address to,\\n        GameData calldata creation,\\n        address editor,\\n        uint64 subId\\n    ) external override onlyMinter() notToZero(to) notToThis(to) returns (uint256 id) {\\n        require(creation.exactNumOfLandsRequired > 0, \\\"EXACT_NUM_OF_LANDS_REQUIRED_ZERO\\\");\\n        (uint256 gameId, uint256 strgId) = _mintGame(from, to, subId, 0, true);\\n\\n        if (editor != address(0)) {\\n            _setGameEditor(to, editor, true);\\n        }\\n        if (creation.assetIdsToAdd.length != 0) {\\n            _addAssets(from, strgId, creation.assetIdsToAdd, creation.assetAmountsToAdd);\\n        }\\n\\n        _metaData[strgId] = creation.uri;\\n        _exactNumOfLandsRequired[strgId] = creation.exactNumOfLandsRequired;\\n        emit GameTokenUpdated(0, gameId, creation);\\n        return gameId;\\n    }\\n\\n    /// @notice Update an existing GAME token.This actually burns old token\\n    /// and mints new token with same basId & incremented version.\\n    /// @param from The one updating the GAME token.\\n    /// @param gameId The current id of the GAME token.\\n    /// @param update The values to use for the update.\\n    /// @return The new gameId.\\n    function updateGame(\\n        address from,\\n        uint256 gameId,\\n        IGameToken.GameData memory update\\n    ) external override onlyMinter() returns (uint256) {\\n        require(update.exactNumOfLandsRequired > 0, \\\"EXACT_NUM_OF_LANDS_REQUIRED_ZERO\\\");\\n        uint256 id = _storageId(gameId);\\n        _addAssets(from, id, update.assetIdsToAdd, update.assetAmountsToAdd);\\n        _removeAssets(id, update.assetIdsToRemove, update.assetAmountsToRemove, _ownerOf(gameId));\\n        _metaData[id] = update.uri;\\n        _exactNumOfLandsRequired[id] = update.exactNumOfLandsRequired;\\n        uint256 newId = _bumpGameVersion(from, gameId);\\n        emit GameTokenUpdated(gameId, newId, update);\\n        return newId;\\n    }\\n\\n    /// @notice Allow token owner to set game editors.\\n    /// @param gameOwner The address of a GAME token creator.\\n    /// @param editor The address of the editor to set.\\n    /// @param isEditor Add or remove the ability to edit.\\n    function setGameEditor(\\n        address gameOwner,\\n        address editor,\\n        bool isEditor\\n    ) external override {\\n        require(_msgSender() == gameOwner, \\\"EDITOR_ACCESS_DENIED\\\");\\n        _setGameEditor(gameOwner, editor, isEditor);\\n    }\\n\\n    /// @notice Transfers creatorship of `original` from `sender` to `to`.\\n    /// @param gameId The current id of the GAME token.\\n    /// @param sender The address of current registered creator.\\n    /// @param to The address to transfer the creatorship to\\n    function transferCreatorship(\\n        uint256 gameId,\\n        address sender,\\n        address to\\n    ) external override notToZero(to) {\\n        require(_ownerOf(gameId) != address(0), \\\"NONEXISTENT_TOKEN\\\");\\n        uint256 id = _storageId(gameId);\\n        address msgSender = _msgSender();\\n        require(msgSender == sender || _superOperators[msgSender], \\\"TRANSFER_ACCESS_DENIED\\\");\\n        require(sender != address(0), \\\"NOT_FROM_ZEROADDRESS\\\");\\n        address originalCreator = address(uint160(id / CREATOR_OFFSET_MULTIPLIER));\\n        address current = creatorOf(gameId);\\n        require(current != to, \\\"CURRENT_=_TO\\\");\\n        require(current == sender, \\\"CURRENT_!=_SENDER\\\");\\n        _creatorship[id] = to;\\n        emit CreatorshipTransfer(originalCreator, current, to);\\n    }\\n\\n    /// @notice Burn a GAME token and recover assets.\\n    /// @param from The address of the one destroying the game.\\n    /// @param to The address to send all GAME assets to.\\n    /// @param gameId The id of the GAME to destroy.\\n    /// @param assetIds The assets to recover from the burnt GAME.\\n    function burnAndRecover(\\n        address from,\\n        address to,\\n        uint256 gameId,\\n        uint256[] calldata assetIds\\n    ) external override {\\n        _burnGame(from, gameId);\\n        _recoverAssets(from, to, gameId, assetIds);\\n    }\\n\\n    /// @notice Burn a GAME token.\\n    /// @param gameId The id of the GAME to destroy.\\n    function burn(uint256 gameId) external override(ERC721BaseToken, IGameToken) {\\n        _burnGame(_msgSender(), gameId);\\n    }\\n\\n    /// @notice Burn a GAME token on behalf of owner.\\n    /// @param from The address whose GAME is being burnt.\\n    /// @param gameId The id of the GAME to burn.\\n    function burnFrom(address from, uint256 gameId) external override(ERC721BaseToken, IGameToken) {\\n        require(from != address(0), \\\"NOT_FROM_ZEROADDRESS\\\");\\n        _burnGame(from, gameId);\\n    }\\n\\n    /// @notice Transfer assets from a burnt GAME.\\n    /// @param from Previous owner of the burnt game.\\n    /// @param to Address that will receive the assets.\\n    /// @param gameId Id of the burnt GAME token.\\n    /// @param assetIds The assets to recover from the burnt GAME.\\n    function recoverAssets(\\n        address from,\\n        address to,\\n        uint256 gameId,\\n        uint256[] memory assetIds\\n    ) public override {\\n        _recoverAssets(from, to, gameId, assetIds);\\n    }\\n\\n    /// @notice Get the amount of each assetId in a GAME.\\n    /// @param gameId The game to query.\\n    /// @param assetIds The assets to get balances for.\\n    function getAssetBalances(uint256 gameId, uint256[] calldata assetIds)\\n        external\\n        view\\n        override\\n        returns (uint256[] memory)\\n    {\\n        uint256 storageId = _storageId(gameId);\\n        require(_ownerOf(gameId) != address(0), \\\"NONEXISTENT_TOKEN\\\");\\n        uint256 length = assetIds.length;\\n        uint256[] memory assets;\\n        assets = new uint256[](length);\\n        for (uint256 i = 0; i < length; i++) {\\n            assets[i] = _gameAssets[storageId][assetIds[i]];\\n        }\\n        return assets;\\n    }\\n\\n    function getExactNumOfLandsRequired(uint256 gameId) external view override returns (uint256) {\\n        uint256 storageId = _storageId(gameId);\\n        return _exactNumOfLandsRequired[storageId];\\n    }\\n\\n    /// @notice Get game editor status.\\n    /// @param gameOwner The address of the owner of the GAME.\\n    /// @param editor The address of the editor to set.\\n    /// @return isEditor Editor status of editor for given tokenId.\\n    function isGameEditor(address gameOwner, address editor) external view override returns (bool isEditor) {\\n        return _gameEditors[gameOwner][editor];\\n    }\\n\\n    /// @notice Called by other contracts to check if this can receive erc1155 batch.\\n    /// @param operator The address of the operator in the current tx.\\n    /// @return the bytes4 value 0xbc197c81.\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address, /*from*/\\n        uint256[] calldata, /*ids*/\\n        uint256[] calldata, /*values*/\\n        bytes calldata /*data*/\\n    ) external view override returns (bytes4) {\\n        if (operator == address(this)) {\\n            return ERC1155_BATCH_RECEIVED;\\n        }\\n        revert(\\\"ERC1155_BATCH_REJECTED\\\");\\n    }\\n\\n    /// @notice Called by other contracts to check if this can receive erc1155 tokens.\\n    /// @param operator The address of the operator in the current tx.\\n    /// @return the bytes4 value 0xf23a6e61.\\n    function onERC1155Received(\\n        address operator,\\n        address, /*from*/\\n        uint256, /*id*/\\n        uint256, /*value*/\\n        bytes calldata /*data*/\\n    ) external view override returns (bytes4) {\\n        if (operator == address(this)) {\\n            return ERC1155_RECEIVED;\\n        }\\n        revert(\\\"ERC1155_REJECTED\\\");\\n    }\\n\\n    /// @notice Return the name of the token contract.\\n    /// @return The name of the token contract.\\n    function name() external pure override returns (string memory) {\\n        return \\\"The Sandbox: GAME token\\\";\\n    }\\n\\n    /// @notice Get the symbol of the token contract.\\n    /// @return the symbol of the token contract.\\n    function symbol() external pure override returns (string memory) {\\n        return \\\"GAME\\\";\\n    }\\n\\n    /// @notice Get the creator of the token type `id`.\\n    /// @param gameId The id of the token to get the creator of.\\n    /// @return the creator of the token type `id`.\\n    function creatorOf(uint256 gameId) public view override returns (address) {\\n        require(gameId != uint256(0), \\\"GAME_NEVER_MINTED\\\");\\n        uint256 id = _storageId(gameId);\\n        address originalCreator = address(uint160(id / CREATOR_OFFSET_MULTIPLIER));\\n        address newCreator = _creatorship[id];\\n        if (newCreator != address(0)) {\\n            return newCreator;\\n        }\\n        return originalCreator;\\n    }\\n\\n    /// @notice Return the URI of a specific token.\\n    /// @param gameId The id of the token.\\n    /// @return uri The URI of the token metadata.\\n    function tokenURI(uint256 gameId) public view override returns (string memory uri) {\\n        require(_ownerOf(gameId) != address(0), \\\"BURNED_OR_NEVER_MINTED\\\");\\n        uint256 id = _storageId(gameId);\\n        return _toFullURI(_metaData[id]);\\n    }\\n\\n    /// @notice Check if the contract supports an interface.\\n    /// 0x01ffc9a7 is ERC-165.\\n    /// 0x80ac58cd is ERC-721.\\n    /// @param id The id of the interface.\\n    /// @return if the interface is supported.\\n    function supportsInterface(bytes4 id) public pure override returns (bool) {\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd || id == 0x5b5e139f;\\n    }\\n\\n    /// @notice Add assets to an existing GAME.\\n    /// @param from The address of the current owner of assets.\\n    /// @param strgId The storageId of the GAME to add assets to.\\n    /// @param assetIds The id of the asset to add to GAME.\\n    /// @param amounts The amount of each asset to add to GAME.\\n    function _addAssets(\\n        address from,\\n        uint256 strgId,\\n        uint256[] memory assetIds,\\n        uint256[] memory amounts\\n    ) internal {\\n        if (assetIds.length == 0) {\\n            return;\\n        }\\n        require(assetIds.length == amounts.length, \\\"INVALID_INPUT_LENGTHS\\\");\\n        uint256 currentValue;\\n        for (uint256 i = 0; i < assetIds.length; i++) {\\n            currentValue = _gameAssets[strgId][assetIds[i]];\\n            require(amounts[i] != 0, \\\"INVALID_ASSET_ADDITION\\\");\\n            _gameAssets[strgId][assetIds[i]] = currentValue + amounts[i];\\n        }\\n        if (assetIds.length == 1) {\\n            _asset.safeTransferFrom(from, address(this), assetIds[0], amounts[0], \\\"\\\");\\n        } else {\\n            _asset.safeBatchTransferFrom(from, address(this), assetIds, amounts, \\\"\\\");\\n        }\\n    }\\n\\n    /// @notice Remove assets from a GAME.\\n    /// @param id The storageId of the GAME to remove assets from.\\n    /// @param assetIds An array of asset Ids to remove.\\n    /// @param values An array of the number of each asset id to remove.\\n    /// @param to The address to send removed assets to.\\n    function _removeAssets(\\n        uint256 id,\\n        uint256[] memory assetIds,\\n        uint256[] memory values,\\n        address to\\n    ) internal {\\n        if (assetIds.length == 0) {\\n            return;\\n        }\\n        require(assetIds.length == values.length && assetIds.length != 0, \\\"INVALID_INPUT_LENGTHS\\\");\\n        uint256 currentValue;\\n        for (uint256 i = 0; i < assetIds.length; i++) {\\n            currentValue = _gameAssets[id][assetIds[i]];\\n            require(currentValue != 0 && values[i] != 0 && values[i] <= currentValue, \\\"INVALID_ASSET_REMOVAL\\\");\\n            _gameAssets[id][assetIds[i]] = currentValue - values[i];\\n        }\\n\\n        if (assetIds.length == 1) {\\n            _asset.safeTransferFrom(address(this), to, assetIds[0], values[0], \\\"\\\");\\n        } else {\\n            _asset.safeBatchTransferFrom(address(this), to, assetIds, values, \\\"\\\");\\n        }\\n    }\\n\\n    /// @dev See burn / burnFrom.\\n    function _burnGame(address from, uint256 gameId) internal {\\n        uint256 storageId = _storageId(gameId);\\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(storageId);\\n        address msgSender = _msgSender();\\n        require(\\n            msgSender == owner ||\\n                (operatorEnabled && _operators[storageId] == msgSender) ||\\n                _superOperators[msgSender] ||\\n                _operatorsForAll[from][msgSender],\\n            \\\"UNAUTHORIZED_BURN\\\"\\n        );\\n\\n        delete _metaData[storageId];\\n        delete _exactNumOfLandsRequired[storageId];\\n        _creatorship[gameId] = address(0);\\n        _burn(from, owner, gameId);\\n    }\\n\\n    /// @dev See recoverAssets.\\n    function _recoverAssets(\\n        address from,\\n        address to,\\n        uint256 gameId,\\n        uint256[] memory assetIds\\n    ) internal notToZero(to) notToThis(to) {\\n        require(_ownerOf(gameId) == address(0), \\\"ONLY_FROM_BURNED_TOKEN\\\");\\n        uint256 storageId = _storageId(gameId);\\n        require(from == _msgSender(), \\\"INVALID_RECOVERY\\\");\\n        _check_withdrawal_authorized(from, gameId);\\n        require(assetIds.length > 0, \\\"WITHDRAWAL_COMPLETE\\\");\\n        uint256[] memory values;\\n        values = new uint256[](assetIds.length);\\n        for (uint256 i = 0; i < assetIds.length; i++) {\\n            values[i] = _gameAssets[storageId][assetIds[i]];\\n            delete _gameAssets[storageId][assetIds[i]];\\n        }\\n        _asset.safeBatchTransferFrom(address(this), to, assetIds, values, \\\"\\\");\\n\\n        GameData memory recovery;\\n        recovery.assetIdsToRemove = assetIds;\\n        recovery.assetAmountsToRemove = values;\\n        emit GameTokenUpdated(gameId, 0, recovery);\\n    }\\n\\n    /// @dev Create a new gameId and associate it with an owner.\\n    /// @param from The address of one creating the game.\\n    /// @param to The address of the Game owner.\\n    /// @param subId The id to use when generating the new GameId.\\n    /// @param version The version number part of the gameId.\\n    /// @param isCreation Whether this is a brand new GAME (as opposed to an update).\\n    /// @return id The newly created gameId.\\n    function _mintGame(\\n        address from,\\n        address to,\\n        uint64 subId,\\n        uint16 version,\\n        bool isCreation\\n    ) internal returns (uint256 id, uint256 storageId) {\\n        uint16 idVersion;\\n        uint256 gameId;\\n        uint256 strgId;\\n        if (isCreation) {\\n            idVersion = 1;\\n            gameId = _generateTokenId(from, subId, _chainIndex, idVersion);\\n            strgId = _storageId(gameId);\\n            require(_owners[strgId] == 0, \\\"STORAGE_ID_REUSE_FORBIDDEN\\\");\\n        } else {\\n            idVersion = version;\\n            gameId = _generateTokenId(from, subId, _chainIndex, idVersion);\\n            strgId = _storageId(gameId);\\n        }\\n\\n        _owners[strgId] = (uint256(idVersion) << 200) + uint256(uint160(to));\\n        _numNFTPerAddress[to]++;\\n        emit Transfer(address(0), to, gameId);\\n        return (gameId, strgId);\\n    }\\n\\n    /// @dev Allow token owner to set game editors.\\n    /// @param gameCreator The address of a GAME creator,\\n    /// @param editor The address of the editor to set.\\n    /// @param isEditor Add or remove the ability to edit.\\n    function _setGameEditor(\\n        address gameCreator,\\n        address editor,\\n        bool isEditor\\n    ) internal {\\n        emit GameEditorSet(gameCreator, editor, isEditor);\\n        _gameEditors[gameCreator][editor] = isEditor;\\n    }\\n\\n    /// @dev Bumps the version number of a game token, buring the previous\\n    /// version and minting a new one.\\n    /// @param from The address of the GAME token owner.\\n    /// @param gameId The Game token to bump the version of.\\n    /// @return The new gameId.\\n    function _bumpGameVersion(address from, uint256 gameId) internal returns (uint256) {\\n        address originalCreator = address(uint160(gameId / CREATOR_OFFSET_MULTIPLIER));\\n        uint64 subId = uint64(gameId / SUBID_MULTIPLIER);\\n        uint16 version = uint16(gameId);\\n        version++;\\n        address owner = _ownerOf(gameId);\\n        if (from == owner) {\\n            // caller is owner or metaTx on owner's behalf\\n            _burn(from, owner, gameId);\\n        } else if (_gameEditors[owner][from]) {\\n            // caller is editor or metaTx on editor's behalf, so we need to pass owner\\n            // instead of from or _burn will fail\\n            _burn(owner, owner, gameId);\\n        }\\n        (uint256 newId, ) = _mintGame(originalCreator, owner, subId, version, false);\\n        address newOwner = _ownerOf(newId);\\n        assert(owner == newOwner);\\n        return newId;\\n    }\\n\\n    /// @dev Get the a full URI string for a given hash + gameId.\\n    /// @param hash The 32 byte IPFS hash.\\n    /// @return The URI string.\\n    function _toFullURI(bytes32 hash) internal pure override returns (string memory) {\\n        return string(abi.encodePacked(\\\"ipfs://bafybei\\\", hash2base32(hash), \\\"/\\\", \\\"game.json\\\"));\\n    }\\n}\\n\",\"keccak256\":\"0x0091eaeb111847035947eee09004e04439155a727b5690cf68bab462ede5b192\",\"license\":\"MIT\"},\"src/solc_0.8/Game/GameMinter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-version\\npragma solidity 0.8.2;\\n\\nimport \\\"./GameBaseToken.sol\\\";\\nimport \\\"../common/interfaces/IGameMinter.sol\\\";\\nimport \\\"@openzeppelin/contracts-0.8/token/ERC20/IERC20.sol\\\";\\nimport \\\"../common/BaseWithStorage/ERC2771Handler.sol\\\";\\n\\ncontract GameMinter is ERC2771Handler, IGameMinter {\\n    ///////////////////////////////  Data //////////////////////////////\\n\\n    GameBaseToken internal immutable _gameToken;\\n    // @todo confirm actual fees\\n    uint256 internal immutable _gameMintingFee;\\n    uint256 internal immutable _gameUpdateFee;\\n    address internal immutable _feeBeneficiary;\\n    IERC20 internal immutable _sand;\\n\\n    ///////////////////////////////  Functions /////////////////////////\\n\\n    constructor(\\n        GameBaseToken gameTokenContract,\\n        address trustedForwarder,\\n        uint256 gameMintingFee,\\n        uint256 gameUpdateFee,\\n        address feeBeneficiary,\\n        IERC20 sand\\n    ) {\\n        _gameToken = gameTokenContract;\\n        _gameMintingFee = gameMintingFee;\\n        _gameUpdateFee = gameUpdateFee;\\n        _feeBeneficiary = feeBeneficiary;\\n        _sand = sand;\\n        ERC2771Handler.__ERC2771Handler_initialize(trustedForwarder);\\n    }\\n\\n    /// @notice Function to create a new GAME token\\n    /// @param to The address who will be assigned ownership of this game.\\n    /// @param creation The struct containing ids & ammounts of assets to add to this game,\\n    /// along with the uri to set.\\n    /// @param editor The address to allow to edit (can also be set later).\\n    /// @param subId A random id created on the backend.\\n    /// @return gameId The id of the new GAME token (erc721)\\n    function createGame(\\n        address to,\\n        GameBaseToken.GameData calldata creation,\\n        address editor,\\n        uint64 subId\\n    ) external override returns (uint256 gameId) {\\n        address msgSender = _msgSender();\\n        _chargeSand(msgSender, _gameMintingFee);\\n        return _gameToken.createGame(msgSender, to, creation, editor, subId);\\n    }\\n\\n    /// @notice Update an existing GAME token.This actually burns old token\\n    /// and mints new token with same basId & incremented version.\\n    /// @param gameId The current id of the GAME token.\\n    /// @param update The values to use for the update.\\n    /// @return newId The new gameId.\\n    function updateGame(uint256 gameId, GameBaseToken.GameData memory update)\\n        external\\n        override\\n        returns (uint256 newId)\\n    {\\n        address gameOwner = _gameToken.ownerOf(gameId);\\n        address msgSender = _msgSender();\\n        require(msgSender == gameOwner || _gameToken.isGameEditor(gameOwner, msgSender), \\\"AUTH_ACCESS_DENIED\\\");\\n        _chargeSand(msgSender, _gameUpdateFee);\\n        return _gameToken.updateGame(msgSender, gameId, update);\\n    }\\n\\n    /// @dev Charge a fee in Sand if conditions are met.\\n    /// @param from The address responsible for paying the fee.\\n    /// @param sandFee The fee that applies to the current operation (create || update).\\n    function _chargeSand(address from, uint256 sandFee) internal {\\n        if (_feeBeneficiary != address(0) && sandFee != 0) {\\n            _sand.transferFrom(from, _feeBeneficiary, sandFee);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0xed8b92cbe2dc314be366113bd58337fa8dbd92d03afa63019da60527c7b97889\",\"license\":\"MIT\"},\"src/solc_0.8/common/BaseWithStorage/ERC2771Handler.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-version\\npragma solidity ^0.8.0;\\n\\n/// @dev minimal ERC2771 handler to keep bytecode-size down.\\n/// based on: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/metatx/ERC2771Context.sol\\n\\ncontract ERC2771Handler {\\n    address internal _trustedForwarder;\\n\\n    function __ERC2771Handler_initialize(address forwarder) internal {\\n        _trustedForwarder = forwarder;\\n    }\\n\\n    function isTrustedForwarder(address forwarder) public view returns (bool) {\\n        return forwarder == _trustedForwarder;\\n    }\\n\\n    function getTrustedForwarder() external view returns (address trustedForwarder) {\\n        return _trustedForwarder;\\n    }\\n\\n    function _msgSender() internal view virtual returns (address sender) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            // The assembly code is more direct than the Solidity version using `abi.decode`.\\n            // solhint-disable-next-line no-inline-assembly\\n            assembly {\\n                sender := shr(96, calldataload(sub(calldatasize(), 20)))\\n            }\\n        } else {\\n            return msg.sender;\\n        }\\n    }\\n\\n    function _msgData() internal view virtual returns (bytes calldata) {\\n        if (isTrustedForwarder(msg.sender)) {\\n            return msg.data[:msg.data.length - 20];\\n        } else {\\n            return msg.data;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9b78a86fc419fc78e618cb6c7892c2c66c4d4a9cac7848d33d91d68aab755caa\",\"license\":\"MIT\"},\"src/solc_0.8/common/BaseWithStorage/ERC721BaseToken.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n/* solhint-disable func-order, code-complexity */\\npragma solidity 0.8.2;\\n\\nimport \\\"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol\\\";\\nimport \\\"@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol\\\";\\nimport \\\"./WithSuperOperators.sol\\\";\\nimport \\\"../interfaces/IERC721MandatoryTokenReceiver.sol\\\";\\nimport \\\"./ERC2771Handler.sol\\\";\\n\\ncontract ERC721BaseToken is IERC721Upgradeable, WithSuperOperators, ERC2771Handler {\\n    using AddressUpgradeable for address;\\n\\n    bytes4 internal constant _ERC721_RECEIVED = 0x150b7a02;\\n    bytes4 internal constant _ERC721_BATCH_RECEIVED = 0x4b808c46;\\n\\n    bytes4 internal constant ERC165ID = 0x01ffc9a7;\\n    bytes4 internal constant ERC721_MANDATORY_RECEIVER = 0x5e8bf644;\\n\\n    uint256 internal constant NOT_ADDRESS = 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000;\\n    uint256 internal constant OPERATOR_FLAG = (2**255);\\n    uint256 internal constant NOT_OPERATOR_FLAG = OPERATOR_FLAG - 1;\\n    uint256 internal constant BURNED_FLAG = (2**160);\\n\\n    mapping(address => uint256) internal _numNFTPerAddress;\\n    mapping(uint256 => uint256) internal _owners;\\n    mapping(address => mapping(address => bool)) internal _operatorsForAll;\\n    mapping(uint256 => address) internal _operators;\\n    uint8 internal _chainIndex;\\n\\n    function __ERC721BaseToken_initialize(uint8 chainIndex) internal {\\n        _chainIndex = chainIndex;\\n    }\\n\\n    /// @notice Approve an operator to spend tokens on the senders behalf.\\n    /// @param operator The address receiving the approval.\\n    /// @param id The id of the token.\\n    function approve(address operator, uint256 id) external override {\\n        uint256 ownerData = _owners[_storageId(id)];\\n        address owner = _ownerOf(id);\\n        address msgSender = _msgSender();\\n        require(owner != address(0), \\\"NONEXISTENT_TOKEN\\\");\\n        require(\\n            owner == msgSender || _superOperators[msgSender] || _operatorsForAll[owner][msgSender],\\n            \\\"UNAUTHORIZED_APPROVAL\\\"\\n        );\\n        _approveFor(ownerData, operator, id);\\n    }\\n\\n    /// @notice Approve an operator to spend tokens on the sender behalf.\\n    /// @param sender The address giving the approval.\\n    /// @param operator The address receiving the approval.\\n    /// @param id The id of the token.\\n    function approveFor(\\n        address sender,\\n        address operator,\\n        uint256 id\\n    ) external {\\n        uint256 ownerData = _owners[_storageId(id)];\\n        address msgSender = _msgSender();\\n        require(sender != address(0), \\\"ZERO_ADDRESS_SENDER\\\");\\n        require(\\n            msgSender == sender || _superOperators[msgSender] || _operatorsForAll[sender][msgSender],\\n            \\\"UNAUTHORIZED_APPROVAL\\\"\\n        );\\n        require(address(uint160(ownerData)) == sender, \\\"OWNER_NOT_SENDER\\\");\\n        _approveFor(ownerData, operator, id);\\n    }\\n\\n    /// @notice Transfer a token between 2 addresses.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param id The id of the token.\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external override {\\n        _checkTransfer(from, to, id);\\n        _transferFrom(from, to, id);\\n        if (to.isContract() && _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER)) {\\n            require(_checkOnERC721Received(_msgSender(), from, to, id, \\\"\\\"), \\\"ERC721_TRANSFER_REJECTED\\\");\\n        }\\n    }\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver know of the transfer.\\n    /// @param from The send of the token.\\n    /// @param to The recipient of the token.\\n    /// @param id The id of the token.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external override {\\n        safeTransferFrom(from, to, id, \\\"\\\");\\n    }\\n\\n    /// @notice Transfer many tokens between 2 addresses.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param ids The ids of the tokens.\\n    /// @param data Additional data.\\n    function batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        bytes calldata data\\n    ) external {\\n        _batchTransferFrom(from, to, ids, data, false);\\n    }\\n\\n    /// @notice Transfer many tokens between 2 addresses, while\\n    /// ensuring the receiving contract has a receiver method.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param ids The ids of the tokens.\\n    /// @param data Additional data.\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        bytes calldata data\\n    ) external {\\n        _batchTransferFrom(from, to, ids, data, true);\\n    }\\n\\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\\n    /// @param sender The address giving the approval.\\n    /// @param operator The address receiving the approval.\\n    /// @param approved The determination of the approval.\\n    function setApprovalForAllFor(\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) external {\\n        require(sender != address(0), \\\"Invalid sender address\\\");\\n        address msgSender = _msgSender();\\n        require(msgSender == sender || _superOperators[msgSender], \\\"UNAUTHORIZED_APPROVE_FOR_ALL\\\");\\n\\n        _setApprovalForAll(sender, operator, approved);\\n    }\\n\\n    /// @notice Set the approval for an operator to manage all the tokens of the sender.\\n    /// @param operator The address receiving the approval.\\n    /// @param approved The determination of the approval.\\n    function setApprovalForAll(address operator, bool approved) external override {\\n        _setApprovalForAll(_msgSender(), operator, approved);\\n    }\\n\\n    /// @notice Burns token `id`.\\n    /// @param id The token which will be burnt.\\n    function burn(uint256 id) external virtual {\\n        _burn(_msgSender(), _ownerOf(id), id);\\n    }\\n\\n    /// @notice Burn token`id` from `from`.\\n    /// @param from address whose token is to be burnt.\\n    /// @param id The token which will be burnt.\\n    function burnFrom(address from, uint256 id) external virtual {\\n        require(from != address(0), \\\"NOT_FROM_ZEROADDRESS\\\");\\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\\n        address msgSender = _msgSender();\\n        require(\\n            msgSender == from ||\\n                (operatorEnabled && _operators[id] == msgSender) ||\\n                _superOperators[msgSender] ||\\n                _operatorsForAll[from][msgSender],\\n            \\\"UNAUTHORIZED_BURN\\\"\\n        );\\n        _burn(from, owner, id);\\n    }\\n\\n    /// @notice Get the number of tokens owned by an address.\\n    /// @param owner The address to look for.\\n    /// @return The number of tokens owned by the address.\\n    function balanceOf(address owner) external view override returns (uint256) {\\n        require(owner != address(0), \\\"ZERO_ADDRESS_OWNER\\\");\\n        return _numNFTPerAddress[owner];\\n    }\\n\\n    /// @notice Get the owner of a token.\\n    /// @param id The id of the token.\\n    /// @return owner The address of the token owner.\\n    function ownerOf(uint256 id) external view override returns (address owner) {\\n        owner = _ownerOf(id);\\n        require(owner != address(0), \\\"NONEXISTANT_TOKEN\\\");\\n    }\\n\\n    /// @notice Get the approved operator for a specific token.\\n    /// @param id The id of the token.\\n    /// @return The address of the operator.\\n    function getApproved(uint256 id) external view override returns (address) {\\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\\n        require(owner != address(0), \\\"NONEXISTENT_TOKEN\\\");\\n        if (operatorEnabled) {\\n            return _operators[id];\\n        } else {\\n            return address(0);\\n        }\\n    }\\n\\n    /// @notice Check if the sender approved the operator.\\n    /// @param owner The address of the owner.\\n    /// @param operator The address of the operator.\\n    /// @return isOperator The status of the approval.\\n    function isApprovedForAll(address owner, address operator) external view override returns (bool isOperator) {\\n        return _operatorsForAll[owner][operator] || _superOperators[operator];\\n    }\\n\\n    /// @notice Transfer a token between 2 addresses letting the receiver knows of the transfer.\\n    /// @param from The sender of the token.\\n    /// @param to The recipient of the token.\\n    /// @param id The id of the token.\\n    /// @param data Additional data.\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        bytes memory data\\n    ) public override {\\n        _checkTransfer(from, to, id);\\n        _transferFrom(from, to, id);\\n        if (to.isContract()) {\\n            require(_checkOnERC721Received(_msgSender(), from, to, id, data), \\\"ERC721_TRANSFER_REJECTED\\\");\\n        }\\n    }\\n\\n    /// @notice Check if the contract supports an interface.\\n    /// 0x01ffc9a7 is ERC-165.\\n    /// 0x80ac58cd is ERC-721\\n    /// @param id The id of the interface.\\n    /// @return Whether the interface is supported.\\n    function supportsInterface(bytes4 id) public pure virtual override returns (bool) {\\n        return id == 0x01ffc9a7 || id == 0x80ac58cd;\\n    }\\n\\n    function isBurned(uint256 estateId) public view returns (bool) {\\n        uint256 storageId = _storageId(estateId);\\n        return (_owners[storageId] & BURNED_FLAG) == BURNED_FLAG;\\n    }\\n\\n    /// @dev By overriding this function in an implementation which inherits this contract, you can enable versioned tokenIds without the extra overhead of writing to a new storage slot in _owners each time a version is incremented. See GameToken._storageId() for an example, where the storageId is the tokenId minus the version number.\\n    /// !!! Caution !!! Overriding this function without taking appropriate care could lead to\\n    /// ownerOf() returning an owner for non-existent tokens. Tests should be written to\\n    /// guard against introducing this bug.\\n    /// @param id The id of a token.\\n    /// @return The id used for storage mappings.\\n    function _storageId(uint256 id) internal view virtual returns (uint256) {\\n        return id;\\n    }\\n\\n    function _updateOwnerData(\\n        uint256 id,\\n        uint256 oldData,\\n        address newOwner,\\n        bool hasOperator\\n    ) internal virtual {\\n        if (hasOperator) {\\n            _owners[_storageId(id)] = (oldData & NOT_ADDRESS) | OPERATOR_FLAG | uint256(uint160(newOwner));\\n        } else {\\n            _owners[_storageId(id)] = ((oldData & NOT_ADDRESS) & NOT_OPERATOR_FLAG) | uint256(uint160(newOwner));\\n        }\\n    }\\n\\n    function _transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) internal {\\n        _numNFTPerAddress[from]--;\\n        _numNFTPerAddress[to]++;\\n        _updateOwnerData(id, _owners[_storageId(id)], to, false);\\n        emit Transfer(from, to, id);\\n    }\\n\\n    /// @dev See approveFor.\\n    function _approveFor(\\n        uint256 ownerData,\\n        address operator,\\n        uint256 id\\n    ) internal {\\n        address owner = _ownerOf(id);\\n        if (operator == address(0)) {\\n            _updateOwnerData(id, ownerData, owner, false);\\n        } else {\\n            _updateOwnerData(id, ownerData, owner, true);\\n            _operators[id] = operator;\\n        }\\n        emit Approval(owner, operator, id);\\n    }\\n\\n    /// @dev See batchTransferFrom.\\n    function _batchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        bytes memory data,\\n        bool safe\\n    ) internal {\\n        address msgSender = _msgSender();\\n        bool authorized = msgSender == from || _superOperators[msgSender] || _operatorsForAll[from][msgSender];\\n\\n        require(from != address(0), \\\"NOT_FROM_ZEROADDRESS\\\");\\n        require(to != address(0), \\\"NOT_TO_ZEROADDRESS\\\");\\n\\n        uint256 numTokens = ids.length;\\n        for (uint256 i = 0; i < ids.length; i++) {\\n            uint256 id = ids[i];\\n            if (id == 0) {\\n                numTokens--;\\n                continue;\\n            }\\n            (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\\n            require(owner == from, \\\"BATCHTRANSFERFROM_NOT_OWNER\\\");\\n            require(authorized || (operatorEnabled && _operators[id] == msgSender), \\\"NOT_AUTHORIZED\\\");\\n            _updateOwnerData(id, _owners[_storageId(id)], to, false);\\n            emit Transfer(from, to, id);\\n        }\\n        if (from != to) {\\n            _numNFTPerAddress[from] -= numTokens;\\n            _numNFTPerAddress[to] += numTokens;\\n        }\\n        if (to.isContract() && (safe || _checkInterfaceWith10000Gas(to, ERC721_MANDATORY_RECEIVER))) {\\n            require(_checkOnERC721BatchReceived(msgSender, from, to, ids, data), \\\"ERC721_BATCH_TRANSFER_REJECTED\\\");\\n        }\\n    }\\n\\n    /// @dev See setApprovalForAll.\\n    function _setApprovalForAll(\\n        address sender,\\n        address operator,\\n        bool approved\\n    ) internal {\\n        require(!_superOperators[operator], \\\"INVALID_APPROVAL_CHANGE\\\");\\n        _operatorsForAll[sender][operator] = approved;\\n\\n        emit ApprovalForAll(sender, operator, approved);\\n    }\\n\\n    /// @dev See burn.\\n    function _burn(\\n        address from,\\n        address owner,\\n        uint256 id\\n    ) internal {\\n        require(from == owner, \\\"NOT_OWNER\\\");\\n        uint256 storageId = _storageId(id);\\n        _owners[storageId] = (_owners[storageId] & NOT_OPERATOR_FLAG) | BURNED_FLAG; // record as non owner but keep track of last owner\\n        _numNFTPerAddress[from]--;\\n        emit Transfer(from, address(0), id);\\n    }\\n\\n    /// @dev Check if receiving contract accepts erc721 transfers.\\n    /// @param operator The address of the operator.\\n    /// @param from The from address, may be different from msg.sender.\\n    /// @param to The adddress we want to transfer to.\\n    /// @param tokenId The id of the token we would like to transfer.\\n    /// @param _data Any additional data to send with the transfer.\\n    /// @return Whether the expected value of 0x150b7a02 is returned.\\n    function _checkOnERC721Received(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256 tokenId,\\n        bytes memory _data\\n    ) internal returns (bool) {\\n        bytes4 retval = IERC721ReceiverUpgradeable(to).onERC721Received(operator, from, tokenId, _data);\\n        return (retval == _ERC721_RECEIVED);\\n    }\\n\\n    /// @dev Check if receiving contract accepts erc721 batch transfers.\\n    /// @param operator The address of the operator.\\n    /// @param from The from address, may be different from msg.sender.\\n    /// @param to The adddress we want to transfer to.\\n    /// @param ids The ids of the tokens we would like to transfer.\\n    /// @param _data Any additional data to send with the transfer.\\n    /// @return Whether the expected value of 0x4b808c46 is returned.\\n    function _checkOnERC721BatchReceived(\\n        address operator,\\n        address from,\\n        address to,\\n        uint256[] memory ids,\\n        bytes memory _data\\n    ) internal returns (bool) {\\n        bytes4 retval = IERC721MandatoryTokenReceiver(to).onERC721BatchReceived(operator, from, ids, _data);\\n        return (retval == _ERC721_BATCH_RECEIVED);\\n    }\\n\\n    /// @dev See ownerOf\\n    function _ownerOf(uint256 id) internal view virtual returns (address) {\\n        uint256 data = _owners[_storageId(id)];\\n        if ((data & BURNED_FLAG) == BURNED_FLAG) {\\n            return address(0);\\n        }\\n        return address(uint160(data));\\n    }\\n\\n    /// @dev Get the owner and operatorEnabled status of a token.\\n    /// @param id The token to query.\\n    /// @return owner The owner of the token.\\n    /// @return operatorEnabled Whether or not operators are enabled for this token.\\n    function _ownerAndOperatorEnabledOf(uint256 id)\\n        internal\\n        view\\n        virtual\\n        returns (address owner, bool operatorEnabled)\\n    {\\n        uint256 data = _owners[_storageId(id)];\\n        if ((data & BURNED_FLAG) == BURNED_FLAG) {\\n            owner = address(0);\\n        } else {\\n            owner = address(uint160(data));\\n        }\\n        operatorEnabled = (data & OPERATOR_FLAG) == OPERATOR_FLAG;\\n    }\\n\\n    /// @dev Check whether a transfer is a meta Transaction or not.\\n    /// @param from The address who initiated the transfer (may differ from msg.sender).\\n    /// @param to The address recieving the token.\\n    /// @param id The token being transferred.\\n    /// @return isMetaTx Whether or not the transaction is a MetaTx.\\n    function _checkTransfer(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) internal view returns (bool isMetaTx) {\\n        (address owner, bool operatorEnabled) = _ownerAndOperatorEnabledOf(id);\\n        address msgSender = _msgSender();\\n        require(owner != address(0), \\\"NONEXISTENT_TOKEN\\\");\\n        require(owner == from, \\\"CHECKTRANSFER_NOT_OWNER\\\");\\n        require(to != address(0), \\\"NOT_TO_ZEROADDRESS\\\");\\n        require(\\n            msgSender == owner ||\\n                _superOperators[msgSender] ||\\n                _operatorsForAll[from][msgSender] ||\\n                (operatorEnabled && _operators[id] == msgSender),\\n            \\\"UNAUTHORIZED_TRANSFER\\\"\\n        );\\n        return true;\\n    }\\n\\n    /// @dev Check if there was enough gas.\\n    /// @param _contract The address of the contract to check.\\n    /// @param interfaceId The id of the interface we want to test.\\n    /// @return Whether or not this check succeeded.\\n    function _checkInterfaceWith10000Gas(address _contract, bytes4 interfaceId) internal view returns (bool) {\\n        bool success;\\n        bool result;\\n        bytes memory callData = abi.encodeWithSelector(ERC165ID, interfaceId);\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly {\\n            let call_ptr := add(0x20, callData)\\n            let call_size := mload(callData)\\n            let output := mload(0x40) // Find empty storage location using \\\"free memory pointer\\\"\\n            mstore(output, 0x0)\\n            success := staticcall(10000, _contract, call_ptr, call_size, output, 0x20) // 32 bytes\\n            result := mload(output)\\n        }\\n        // (10000 / 63) \\\"not enough for supportsInterface(...)\\\" // consume all gas, so caller can potentially know that there was not enough gas\\n        assert(gasleft() > 158);\\n        return success && result;\\n    }\\n}\\n\",\"keccak256\":\"0x97ed60ed2a69e25bdbf833cef61761a4a7fbf73e126647ce29ebaba23fdd89bf\",\"license\":\"MIT\"},\"src/solc_0.8/common/BaseWithStorage/ImmutableERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity ^0.8.0;\\n\\nimport \\\"../BaseWithStorage/ERC721BaseToken.sol\\\";\\n\\ncontract ImmutableERC721 is ERC721BaseToken {\\n    uint256 internal constant CREATOR_OFFSET_MULTIPLIER = uint256(2)**(256 - 160);\\n    uint256 internal constant SUBID_MULTIPLIER = uint256(2)**(256 - 224);\\n    uint256 internal constant CHAIN_INDEX_OFFSET_MULTIPLIER = uint256(2)**(256 - 160 - 64 - 16);\\n    uint256 internal constant STORAGE_ID_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000;\\n    uint256 internal constant VERSION_MASK = 0x000000FFFFFFFF00000000000000000000000000000000000000000000000000;\\n\\n    bytes32 internal constant base32Alphabet = 0x6162636465666768696A6B6C6D6E6F707172737475767778797A323334353637;\\n\\n    /// @dev An implementation which handles versioned tokenIds.\\n    /// @param id The tokenId to get the owner of.\\n    /// @return The address of the owner.\\n    function _ownerOf(uint256 id) internal view virtual override returns (address) {\\n        uint256 packedData = _owners[_storageId(id)];\\n        uint16 idVersion = uint16(id);\\n        uint16 storageVersion = uint16((packedData & VERSION_MASK) >> 200);\\n\\n        if (((packedData & BURNED_FLAG) == BURNED_FLAG) || idVersion != storageVersion) {\\n            return address(0); //should be here\\n        }\\n\\n        return address(uint160(packedData));\\n    }\\n\\n    /// @dev Check if a withdrawal is allowed.\\n    /// @param from The address requesting the withdrawal.\\n    /// @param tokenId The id of the token to withdraw assets from.\\n    function _check_withdrawal_authorized(address from, uint256 tokenId) internal view virtual {\\n        require(from != address(uint160(0)), \\\"SENDER_ZERO_ADDRESS\\\");\\n        require(from == _withdrawalOwnerOf(tokenId), \\\"LAST_OWNER_NOT_EQUAL_SENDER\\\");\\n    }\\n\\n    /// @dev Get the address allowed to withdraw associated tokens from the parent token.\\n    /// If too many associated tokens in TOKEN, block.gaslimit won't allow detroy and withdraw in 1 tx.\\n    /// An owner may destroy their token, then withdraw associated tokens in a later tx (even\\n    /// though ownerOf(id) would be address(0) after burning.)\\n    /// @param id The id of the token to query.\\n    /// @return the address of the owner before burning.\\n    function _withdrawalOwnerOf(uint256 id) internal view virtual returns (address) {\\n        uint256 packedData = _owners[_storageId(id)];\\n        return address(uint160(packedData));\\n    }\\n\\n    /// @notice Get the storageID (no chainIndex or version data), which is constant for a given token.\\n    /// @param tokenId The tokenId for which to find the first token Id.\\n    /// @return The storage id for this token.\\n    function getStorageId(uint256 tokenId) external pure virtual returns (uint256) {\\n        return _storageId(tokenId);\\n    }\\n\\n    /// @dev Get the storageId (full id without the version number) from the full tokenId.\\n    /// @param id The full tokenId for the GAME token.\\n    /// @return The storageId.\\n    function _storageId(uint256 id) internal pure virtual override returns (uint256) {\\n        return uint256(id & STORAGE_ID_MASK);\\n    }\\n\\n    /// @dev Get the a full URI string for a given hash + gameId.\\n    /// @param hash The 32 byte IPFS hash.\\n    /// @return The URI string.\\n    function _toFullURI(bytes32 hash) internal pure virtual returns (string memory) {\\n        return string(abi.encodePacked(\\\"ipfs://bafybei\\\", hash2base32(hash), \\\"/\\\", \\\"token.json\\\"));\\n    }\\n\\n    /// @dev Create a new tokenId and associate it with an owner.\\n    /// This is a packed id, consisting of 4 parts:\\n    /// the creator's address, a uint64 subId, a uint18 chainIndex and a uint16 version.\\n    /// @param creator The address of the Token creator.\\n    /// @param subId The id used to generate the id.\\n    /// @param version The publicversion used to generate the id.\\n    function _generateTokenId(\\n        address creator,\\n        uint64 subId,\\n        uint8 chainIndex,\\n        uint16 version\\n    ) internal pure returns (uint256) {\\n        return\\n            uint256(uint160(creator)) *\\n            CREATOR_OFFSET_MULTIPLIER +\\n            uint64(subId) *\\n            SUBID_MULTIPLIER +\\n            chainIndex *\\n            CHAIN_INDEX_OFFSET_MULTIPLIER +\\n            uint16(version);\\n    }\\n\\n    /// @dev Convert a 32 byte hash to a base 32 string.\\n    /// @param hash A 32 byte (IPFS) hash.\\n    /// @return _uintAsString The hash as a base 32 string.\\n    // solhint-disable-next-line security/no-assign-params\\n    function hash2base32(bytes32 hash) internal pure returns (string memory _uintAsString) {\\n        uint256 _i = uint256(hash);\\n        uint256 k = 52;\\n        bytes memory bstr = new bytes(k);\\n        bstr[--k] = base32Alphabet[uint8((_i % 8) << 2)]; // uint8 s = uint8((256 - skip) % 5);  // (_i % (2**s)) << (5-s)\\n        _i /= 8;\\n        while (k > 0) {\\n            bstr[--k] = base32Alphabet[_i % 32];\\n            _i /= 32;\\n        }\\n        return string(bstr);\\n    }\\n}\\n\",\"keccak256\":\"0x6d94104194529bc414a00e952a32aa90e9c8b82ac3cedfb72b173e4a1826bb8e\",\"license\":\"MIT\"},\"src/solc_0.8/common/BaseWithStorage/WithAdmin.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-version\\npragma solidity 0.8.2;\\n\\ncontract WithAdmin {\\n    address internal _admin;\\n\\n    /// @dev Emits when the contract administrator is changed.\\n    /// @param oldAdmin The address of the previous administrator.\\n    /// @param newAdmin The address of the new administrator.\\n    event AdminChanged(address oldAdmin, address newAdmin);\\n\\n    modifier onlyAdmin() {\\n        require(msg.sender == _admin, \\\"ADMIN_ONLY\\\");\\n        _;\\n    }\\n\\n    /// @dev Get the current administrator of this contract.\\n    /// @return The current administrator of this contract.\\n    function getAdmin() external view returns (address) {\\n        return _admin;\\n    }\\n\\n    /// @dev Change the administrator to be `newAdmin`.\\n    /// @param newAdmin The address of the new administrator.\\n    function changeAdmin(address newAdmin) external {\\n        require(msg.sender == _admin, \\\"ADMIN_ACCESS_DENIED\\\");\\n        emit AdminChanged(_admin, newAdmin);\\n        _admin = newAdmin;\\n    }\\n}\\n\",\"keccak256\":\"0xf2ce40f1b23052a50a5b2d5ad61fbc04ab6c9fb2e5b1dba17ccddf4507e4649f\",\"license\":\"MIT\"},\"src/solc_0.8/common/BaseWithStorage/WithMinter.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-version\\npragma solidity 0.8.2;\\n\\nimport \\\"./WithAdmin.sol\\\";\\n\\ncontract WithMinter is WithAdmin {\\n    address internal _minter;\\n\\n    /// @dev Emits when the Minter address is changed\\n    /// @param oldMinter The previous Minter address\\n    /// @param newMinter The new Minter address\\n    event MinterChanged(address oldMinter, address newMinter);\\n\\n    modifier onlyMinter() {\\n        require(msg.sender == _minter, \\\"MINTER_ACCESS_DENIED\\\");\\n        _;\\n    }\\n\\n    /// @dev Get the current minter of this contract.\\n    /// @return The current minter of this contract.\\n    function getMinter() external view returns (address) {\\n        return _minter;\\n    }\\n\\n    /// @dev Change the minter to be `newMinter`.\\n    /// @param newMinter The address of the new minter.\\n    function changeMinter(address newMinter) external onlyAdmin() {\\n        emit MinterChanged(_minter, newMinter);\\n        _minter = newMinter;\\n    }\\n}\\n\",\"keccak256\":\"0xf9b764b1596ab97154b71ca8b57980695a9787f5f9f7f970976193065bde2206\",\"license\":\"MIT\"},\"src/solc_0.8/common/BaseWithStorage/WithSuperOperators.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-version\\npragma solidity 0.8.2;\\n\\nimport \\\"./WithAdmin.sol\\\";\\n\\ncontract WithSuperOperators is WithAdmin {\\n    mapping(address => bool) internal _superOperators;\\n\\n    event SuperOperator(address superOperator, bool enabled);\\n\\n    /// @notice Enable or disable the ability of `superOperator` to transfer tokens of all (superOperator rights).\\n    /// @param superOperator address that will be given/removed superOperator right.\\n    /// @param enabled set whether the superOperator is enabled or disabled.\\n    function setSuperOperator(address superOperator, bool enabled) external {\\n        require(msg.sender == _admin, \\\"only admin is allowed to add super operators\\\");\\n        _superOperators[superOperator] = enabled;\\n        emit SuperOperator(superOperator, enabled);\\n    }\\n\\n    /// @notice check whether address `who` is given superOperator rights.\\n    /// @param who The address to query.\\n    /// @return whether the address has superOperator rights.\\n    function isSuperOperator(address who) public view returns (bool) {\\n        return _superOperators[who];\\n    }\\n}\\n\",\"keccak256\":\"0xa0d9b0e08ccae5e6b1f56e41ef750a68686d8958bc398369ac283aa4440f87ab\",\"license\":\"MIT\"},\"src/solc_0.8/common/interfaces/IAssetToken.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-version\\npragma solidity 0.8.2;\\n\\ninterface IAssetToken {\\n    function mint(\\n        address creator,\\n        uint40 packId,\\n        bytes32 hash,\\n        uint256 supply,\\n        uint8 rarity,\\n        address owner,\\n        bytes calldata data\\n    ) external returns (uint256 id);\\n\\n    function mintMultiple(\\n        address creator,\\n        uint40 packId,\\n        bytes32 hash,\\n        uint256[] calldata supplies,\\n        bytes calldata rarityPack,\\n        address owner,\\n        bytes calldata data\\n    ) external returns (uint256[] memory ids);\\n\\n    // fails on non-NFT or nft who do not have collection (was a mistake)\\n    function collectionOf(uint256 id) external view returns (uint256);\\n\\n    function balanceOf(address owner, uint256 id) external view returns (uint256);\\n\\n    // return true for Non-NFT ERC1155 tokens which exists\\n    function isCollection(uint256 id) external view returns (bool);\\n\\n    function collectionIndexOf(uint256 id) external view returns (uint256);\\n\\n    function extractERC721From(\\n        address sender,\\n        uint256 id,\\n        address to\\n    ) external returns (uint256 newId);\\n\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id\\n    ) external;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 id,\\n        uint256 value,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        bytes calldata data\\n    ) external;\\n\\n    function safeBatchTransferFrom(\\n        address from,\\n        address to,\\n        uint256[] calldata ids,\\n        uint256[] calldata values,\\n        bytes calldata data\\n    ) external;\\n\\n    function isSuperOperator(address who) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xb031abbf5d18794cc8f466bda0d029f61d507ac08be2a14aa57a704e3c7d6563\",\"license\":\"MIT\"},\"src/solc_0.8/common/interfaces/IERC721MandatoryTokenReceiver.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-version\\npragma solidity 0.8.2;\\n\\n/// @dev Note: The ERC-165 identifier for this interface is 0x5e8bf644.\\ninterface IERC721MandatoryTokenReceiver {\\n    function onERC721BatchReceived(\\n        address operator,\\n        address from,\\n        uint256[] calldata ids,\\n        bytes calldata data\\n    ) external returns (bytes4); // needs to return 0x4b808c46\\n\\n    function onERC721Received(\\n        address operator,\\n        address from,\\n        uint256 tokenId,\\n        bytes calldata data\\n    ) external returns (bytes4); // needs to return 0x150b7a02\\n\\n    // needs to implements EIP-165\\n    // function supportsInterface(bytes4 interfaceId)\\n    //     external\\n    //     view\\n    //     returns (bool);\\n}\\n\",\"keccak256\":\"0xb2a8c2fcf496f383bedc0f2925fb9ff51e7a725828fcc73a22fd24f66c57c857\",\"license\":\"MIT\"},\"src/solc_0.8/common/interfaces/IGameMinter.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-version\\npragma solidity 0.8.2;\\n\\nimport \\\"./IGameToken.sol\\\";\\n\\ninterface IGameMinter {\\n    function createGame(\\n        address to,\\n        IGameToken.GameData calldata creation,\\n        address editor,\\n        uint64 subId\\n    ) external returns (uint256 gameId);\\n\\n    function updateGame(uint256 gameId, IGameToken.GameData memory update) external returns (uint256 newId);\\n}\\n\",\"keccak256\":\"0x28ee4dba3bbb4cbb167cd9e2c5fce600e8950789538e186bd392ae9a08d65c60\",\"license\":\"MIT\"},\"src/solc_0.8/common/interfaces/IGameToken.sol\":{\"content\":\"//SPDX-License-Identifier: MIT\\n// solhint-disable-next-line compiler-version\\npragma solidity 0.8.2;\\n\\n/// @title Interface for the Game token\\n\\ninterface IGameToken {\\n    struct GameData {\\n        uint256[] assetIdsToRemove;\\n        uint256[] assetAmountsToRemove;\\n        uint256[] assetIdsToAdd;\\n        uint256[] assetAmountsToAdd;\\n        bytes32 uri; // ipfs hash (without the prefix, assume cidv1 folder)\\n        uint256 exactNumOfLandsRequired;\\n    }\\n\\n    function createGame(\\n        address from,\\n        address to,\\n        GameData calldata creation,\\n        address editor,\\n        uint64 subId\\n    ) external returns (uint256 id);\\n\\n    function burn(uint256 gameId) external;\\n\\n    function burnFrom(address from, uint256 gameId) external;\\n\\n    function recoverAssets(\\n        address from,\\n        address to,\\n        uint256 gameId,\\n        uint256[] calldata assetIds\\n    ) external;\\n\\n    function burnAndRecover(\\n        address from,\\n        address to,\\n        uint256 gameId,\\n        uint256[] calldata assetIds\\n    ) external;\\n\\n    function updateGame(\\n        address from,\\n        uint256 gameId,\\n        GameData calldata update\\n    ) external returns (uint256);\\n\\n    function getAssetBalances(uint256 gameId, uint256[] calldata assetIds) external view returns (uint256[] calldata);\\n\\n    function getExactNumOfLandsRequired(uint256 gameId) external view returns (uint256);\\n\\n    function setGameEditor(\\n        address gameCreator,\\n        address editor,\\n        bool isEditor\\n    ) external;\\n\\n    function isGameEditor(address gameOwner, address editor) external view returns (bool isEditor);\\n\\n    function creatorOf(uint256 id) external view returns (address);\\n\\n    function transferCreatorship(\\n        uint256 gameId,\\n        address sender,\\n        address to\\n    ) external;\\n\\n    function name() external pure returns (string memory);\\n\\n    function symbol() external pure returns (string memory);\\n\\n    function tokenURI(uint256 gameId) external returns (string memory uri);\\n\\n    function onERC1155Received(\\n        address operator,\\n        address, /*from*/\\n        uint256, /*id*/\\n        uint256, /*value*/\\n        bytes calldata /*data*/\\n    ) external view returns (bytes4);\\n\\n    function onERC1155BatchReceived(\\n        address operator,\\n        address, /*from*/\\n        uint256[] calldata, /*ids*/\\n        uint256[] calldata, /*values*/\\n        bytes calldata /*data*/\\n    ) external view returns (bytes4);\\n}\\n\",\"keccak256\":\"0xd34d80865a5d3eaa47108b91ce04f9cd67b528eb7ac4d48a3f72b0f278a325d8\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x61012060405234801561001157600080fd5b50604051610e33380380610e33833981016040819052610030916100a0565b606086811b6001600160601b031990811660805260a086905260c085905283821b811660e0529082901b16610100526100738561007e602090811b6104dd17901c565b50505050505061012b565b600080546001600160a01b0319166001600160a01b0392909216919091179055565b60008060008060008060c087890312156100b8578182fd5b86516100c381610113565b60208801519096506100d481610113565b80955050604087015193506060870151925060808701516100f481610113565b60a088015190925061010581610113565b809150509295509295509295565b6001600160a01b038116811461012857600080fd5b50565b60805160601c60a05160c05160e05160601c6101005160601c610ca0610193600039600061060201526000818161056101526105d3015260006103f50152600060ff015260008181610153015281816102280152818161030b01526104490152610ca06000f3fe608060405234801561001057600080fd5b506004361061004c5760003560e01c8063572b6c0514610051578063ce1b815f14610088578063cfd99db7146100a8578063ebb31f7d146100c9575b600080fd5b61007361005f366004610706565b6000546001600160a01b0390811691161490565b60405190151581526020015b60405180910390f35b6100906100dc565b6040516001600160a01b03909116815260200161007f565b6100bb6100b6366004610745565b6100ec565b60405190815260200161007f565b6100bb6100d7366004610800565b6101ec565b6000546001600160a01b03165b90565b6000806100f7610517565b9050610123817f000000000000000000000000000000000000000000000000000000000000000061055f565b6040517fa313a4640000000000000000000000000000000000000000000000000000000081526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063a313a464906101909084908a908a908a908a9060040161097b565b602060405180830381600087803b1580156101aa57600080fd5b505af11580156101be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101e291906107e8565b9695505050505050565b6040517f6352211e0000000000000000000000000000000000000000000000000000000081526004810183905260009081906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690636352211e9060240160206040518083038186803b15801561026a57600080fd5b505afa15801561027e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102a29190610729565b905060006102ae610517565b9050816001600160a01b0316816001600160a01b0316148061038557506040517fa776b8820000000000000000000000000000000000000000000000000000000081526001600160a01b03838116600483015282811660248301527f0000000000000000000000000000000000000000000000000000000000000000169063a776b8829060440160206040518083038186803b15801561034d57600080fd5b505afa158015610361573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061038591906107c8565b6103ef576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f415554485f4143434553535f44454e4945440000000000000000000000000000604482015260640160405180910390fd5b610419817f000000000000000000000000000000000000000000000000000000000000000061055f565b6040517f03e97cb20000000000000000000000000000000000000000000000000000000081526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906303e97cb29061048290849089908990600401610a9a565b602060405180830381600087803b15801561049c57600080fd5b505af11580156104b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104d491906107e8565b95945050505050565b600080547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0392909216919091179055565b600080546001600160a01b031633141561055857507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c6100e9565b50336100e9565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161580159061059657508015155b15610680576040517f23b872dd0000000000000000000000000000000000000000000000000000000081526001600160a01b0383811660048301527f000000000000000000000000000000000000000000000000000000000000000081166024830152604482018390527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401602060405180830381600087803b15801561064657600080fd5b505af115801561065a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061067e91906107c8565b505b5050565b600082601f830112610694578081fd5b8135602067ffffffffffffffff8211156106b0576106b0610c23565b8082026106be828201610b67565b8381528281019086840183880185018910156106d8578687fd5b8693505b858410156106fa5780358352600193909301929184019184016106dc565b50979650505050505050565b600060208284031215610717578081fd5b813561072281610c52565b9392505050565b60006020828403121561073a578081fd5b815161072281610c52565b6000806000806080858703121561075a578283fd5b843561076581610c52565b9350602085013567ffffffffffffffff80821115610781578485fd5b9086019060c08289031215610794578485fd5b9093506040860135906107a682610c52565b90925060608601359080821682146107bc578283fd5b50939692955090935050565b6000602082840312156107d9578081fd5b81518015158114610722578182fd5b6000602082840312156107f9578081fd5b5051919050565b60008060408385031215610812578182fd5b82359150602083013567ffffffffffffffff80821115610830578283fd5b9084019060c08287031215610843578283fd5b61084d60c0610b67565b82358281111561085b578485fd5b61086788828601610684565b82525060208301358281111561087b578485fd5b61088788828601610684565b60208301525060408301358281111561089e578485fd5b6108aa88828601610684565b6040830152506060830135828111156108c1578485fd5b6108cd88828601610684565b6060830152506080830135608082015260a083013560a08201528093505050509250929050565b60008284527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115610925578081fd5b6020830280836020870137939093016020019283525090919050565b6000815180845260208085019450808401835b8381101561097057815187529582019590820190600101610954565b509495945050505050565b6001600160a01b0386811682528516602082015260a0604082015260006109a28580610bb6565b60c060a08501526109b8610160850182846108f4565b9150506109c86020870187610bb6565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60808685030160c08701526109fe8483856108f4565b9350610a0d60408a018a610bb6565b93509150808685030160e0870152610a268484846108f4565b9350610a3560608a018a610bb6565b93509150808685030161010087015250610a508383836108f4565b608089013561012087015260a08901356101408701526001600160a01b03881660608701529350610a8092505050565b67ffffffffffffffff831660808301529695505050505050565b60006001600160a01b038516825283602083015260606040830152825160c06060840152610acc610120840182610941565b905060208401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa080858403016080860152610b088383610941565b925060408601519150808584030160a0860152610b258383610941565b925060608601519150808584030160c086015250610b438282610941565b915050608084015160e084015260a084015161010084015280915050949350505050565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715610bae57610bae610c23565b604052919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112610bea578283fd5b830160208101925035905067ffffffffffffffff811115610c0a57600080fd5b602081023603831315610c1c57600080fd5b9250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6001600160a01b0381168114610c6757600080fd5b5056fea2646970667358221220588f16bd4fa00e7bade82c3c72e073728d0b56a9c484244c4e780eb915967e9364736f6c63430008020033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b506004361061004c5760003560e01c8063572b6c0514610051578063ce1b815f14610088578063cfd99db7146100a8578063ebb31f7d146100c9575b600080fd5b61007361005f366004610706565b6000546001600160a01b0390811691161490565b60405190151581526020015b60405180910390f35b6100906100dc565b6040516001600160a01b03909116815260200161007f565b6100bb6100b6366004610745565b6100ec565b60405190815260200161007f565b6100bb6100d7366004610800565b6101ec565b6000546001600160a01b03165b90565b6000806100f7610517565b9050610123817f000000000000000000000000000000000000000000000000000000000000000061055f565b6040517fa313a4640000000000000000000000000000000000000000000000000000000081526001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000169063a313a464906101909084908a908a908a908a9060040161097b565b602060405180830381600087803b1580156101aa57600080fd5b505af11580156101be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101e291906107e8565b9695505050505050565b6040517f6352211e0000000000000000000000000000000000000000000000000000000081526004810183905260009081906001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001690636352211e9060240160206040518083038186803b15801561026a57600080fd5b505afa15801561027e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102a29190610729565b905060006102ae610517565b9050816001600160a01b0316816001600160a01b0316148061038557506040517fa776b8820000000000000000000000000000000000000000000000000000000081526001600160a01b03838116600483015282811660248301527f0000000000000000000000000000000000000000000000000000000000000000169063a776b8829060440160206040518083038186803b15801561034d57600080fd5b505afa158015610361573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061038591906107c8565b6103ef576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f415554485f4143434553535f44454e4945440000000000000000000000000000604482015260640160405180910390fd5b610419817f000000000000000000000000000000000000000000000000000000000000000061055f565b6040517f03e97cb20000000000000000000000000000000000000000000000000000000081526001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016906303e97cb29061048290849089908990600401610a9a565b602060405180830381600087803b15801561049c57600080fd5b505af11580156104b0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104d491906107e8565b95945050505050565b600080547fffffffffffffffffffffffff0000000000000000000000000000000000000000166001600160a01b0392909216919091179055565b600080546001600160a01b031633141561055857507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec36013560601c6100e9565b50336100e9565b7f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03161580159061059657508015155b15610680576040517f23b872dd0000000000000000000000000000000000000000000000000000000081526001600160a01b0383811660048301527f000000000000000000000000000000000000000000000000000000000000000081166024830152604482018390527f000000000000000000000000000000000000000000000000000000000000000016906323b872dd90606401602060405180830381600087803b15801561064657600080fd5b505af115801561065a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061067e91906107c8565b505b5050565b600082601f830112610694578081fd5b8135602067ffffffffffffffff8211156106b0576106b0610c23565b8082026106be828201610b67565b8381528281019086840183880185018910156106d8578687fd5b8693505b858410156106fa5780358352600193909301929184019184016106dc565b50979650505050505050565b600060208284031215610717578081fd5b813561072281610c52565b9392505050565b60006020828403121561073a578081fd5b815161072281610c52565b6000806000806080858703121561075a578283fd5b843561076581610c52565b9350602085013567ffffffffffffffff80821115610781578485fd5b9086019060c08289031215610794578485fd5b9093506040860135906107a682610c52565b90925060608601359080821682146107bc578283fd5b50939692955090935050565b6000602082840312156107d9578081fd5b81518015158114610722578182fd5b6000602082840312156107f9578081fd5b5051919050565b60008060408385031215610812578182fd5b82359150602083013567ffffffffffffffff80821115610830578283fd5b9084019060c08287031215610843578283fd5b61084d60c0610b67565b82358281111561085b578485fd5b61086788828601610684565b82525060208301358281111561087b578485fd5b61088788828601610684565b60208301525060408301358281111561089e578485fd5b6108aa88828601610684565b6040830152506060830135828111156108c1578485fd5b6108cd88828601610684565b6060830152506080830135608082015260a083013560a08201528093505050509250929050565b60008284527f07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831115610925578081fd5b6020830280836020870137939093016020019283525090919050565b6000815180845260208085019450808401835b8381101561097057815187529582019590820190600101610954565b509495945050505050565b6001600160a01b0386811682528516602082015260a0604082015260006109a28580610bb6565b60c060a08501526109b8610160850182846108f4565b9150506109c86020870187610bb6565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60808685030160c08701526109fe8483856108f4565b9350610a0d60408a018a610bb6565b93509150808685030160e0870152610a268484846108f4565b9350610a3560608a018a610bb6565b93509150808685030161010087015250610a508383836108f4565b608089013561012087015260a08901356101408701526001600160a01b03881660608701529350610a8092505050565b67ffffffffffffffff831660808301529695505050505050565b60006001600160a01b038516825283602083015260606040830152825160c06060840152610acc610120840182610941565b905060208401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa080858403016080860152610b088383610941565b925060408601519150808584030160a0860152610b258383610941565b925060608601519150808584030160c086015250610b438282610941565b915050608084015160e084015260a084015161010084015280915050949350505050565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715610bae57610bae610c23565b604052919050565b60008083357fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1843603018112610bea578283fd5b830160208101925035905067ffffffffffffffff811115610c0a57600080fd5b602081023603831315610c1c57600080fd5b9250929050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6001600160a01b0381168114610c6757600080fd5b5056fea2646970667358221220588f16bd4fa00e7bade82c3c72e073728d0b56a9c484244c4e780eb915967e9364736f6c63430008020033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "createGame(address,(uint256[],uint256[],uint256[],uint256[],bytes32,uint256),address,uint64)": {
        "params": {
          "creation": "The struct containing ids & ammounts of assets to add to this game, along with the uri to set.",
          "editor": "The address to allow to edit (can also be set later).",
          "subId": "A random id created on the backend.",
          "to": "The address who will be assigned ownership of this game."
        },
        "returns": {
          "gameId": "The id of the new GAME token (erc721)"
        }
      },
      "updateGame(uint256,(uint256[],uint256[],uint256[],uint256[],bytes32,uint256))": {
        "params": {
          "gameId": "The current id of the GAME token.",
          "update": "The values to use for the update."
        },
        "returns": {
          "newId": "The new gameId."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "createGame(address,(uint256[],uint256[],uint256[],uint256[],bytes32,uint256),address,uint64)": {
        "notice": "Function to create a new GAME token"
      },
      "updateGame(uint256,(uint256[],uint256[],uint256[],uint256[],bytes32,uint256))": {
        "notice": "Update an existing GAME token.This actually burns old token and mints new token with same basId & incremented version."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 29950,
        "contract": "src/solc_0.8/Game/GameMinter.sol:GameMinter",
        "label": "_trustedForwarder",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      }
    }
  }
}